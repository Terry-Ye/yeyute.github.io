[{"title":"适配器设计模式","date":"2016-05-01T15:44:52.000Z","path":"2016/05/01/适配器模式/","text":"适配器的适用场景 代码的复用性需求多的。 就像不同的手机充电一样，需要一个适配器使usb连接头和墙上插座相互兼容，分解问题可以得到 usb连接头 -&gt;不变 插座不变 -&gt;不变 数据线 -&gt;变 活动专题，例抽奖，固定的规则是充值有抽奖机会，但是突然来了一个需求说充值还要分享才能有抽奖机会，这时可以运用上这个设计模式 题目（来自于php 设计模式 书） - 假设一个企业网站同时销售软件服务和软件产品，目前所有的交易都在美国进行，后续业务决定向欧洲发展要增加货币换算（增加适配器） 优点 灵活性扩展性都很好 将目标类和适配者类解耦 适配器所涉及的角色包括下面几种：目标（Target）：定义一个客户端使用的特定接口。客户端（Client）：使用目标接口，与和目标接口一致的对象合作。被适配者（Adaptee）：一个现存需要适配的接口。适配器（Adapter）：负责将Adaptee的接口转换为Target的接口。适配器是一个具体的类，这是该模式的核心。适配器分为类适配器和对象适配器两种，下面将详细讲述。 案例一来自 php 设计模式 一书的适配器设计模式案例**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * EuroCalc.php * 美元 - 能累加购买的服务和产品的价格 来自于php 设计模式 */class DollarCalc &#123; private $dollar; private $product; private $service; public $rate = 1; public function requestCalc($productNow,$serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;dollar = $this-&gt;product + $this-&gt;service; return $this-&gt;requestCount(); &#125; private function requestCount() &#123; $this-&gt;dollar *= $this-&gt;rate; return $this-&gt;dollar; &#125;&#125;/** * EuroCalc.php * 欧元 - 能累加购买的服务和产品的价格 */class EuroCalc &#123; private $euro; private $product; private $service; public $rate = 1; public function requestCalc($productNow,$serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;euro = $this-&gt;product + $this-&gt;service; return $this-&gt;requestCount(); &#125; private function requestCount() &#123; $this-&gt;euro *= $this-&gt;rate; return $this-&gt;euro; &#125;&#125;/** * 接口 ITarget.php */interface ITarget &#123; function requester();&#125;/** * 例：找一个合适的适配器来适合欧洲的插座一样，以下就是创建这个适配器 * EuroAdapter 实现了一个接口又扩展了一个类 */class EuroAdapter extends EuroCalc implements ITarget &#123; public function __construct() &#123; $this-&gt;requester(); &#125; public function requester() &#123; $this-&gt;rate = 0.8111; return $this-&gt;rate; &#125;&#125;/** * 用户 */class Client &#123; private $euroRequest; private $dollarRequest; public function __construct() &#123; $this-&gt;euroRequest = new EuroAdapter(); $this-&gt;dollarRequest = new DollarCalc(); $euros = \"&amp;#8364;\"; echo \"Euros:$euros\".$this-&gt;makeAdapterRequest($this-&gt;euroRequest).\"&lt;br /&gt;\"; echo \"dollar:\".$this-&gt;makeDollarRequest($this-&gt;dollarRequest); &#125; public function makeAdapterRequest(ITarget $req) &#123; return $req-&gt;requestCalc(40,50); &#125; public function makeDollarRequest(DollarCalc $req) &#123; return $req-&gt;requestCalc(40,50); &#125;&#125;$worker = new Client(); 案例二 个人运用于自动化活动专题的接口设计抽奖例子（代码只显示对应的设计逻辑部分） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?php/** * 适配器模式 - 抽奖接口 * comment 当后台规则不满足自动化，可以添加对应的适配器，增加代码的复用 * author AT */namespace controller;// 每个月份对应的适配器 06年3月 = SixMarchuse \\Adapter\\SixMarch\\LotteryAdapter;/** * 抽奖接口 入口文件 */final class Lottery extends WebController&#123; // 活动的配置信息 存放后台配置的活动信息 private $hd_info; public function __construct() &#123; // 加载配置信息 $this-&gt;hd_info = ''; &#125; public function _lottery() &#123; // 实例 $lottery = new LotteryAdapter($hd_info); // 取得抽奖结果 $rs = $lottery-&gt;_getLotteryResult(); return $rs; &#125;&#125;namespace controller;use \\bbts\\App as BaseApp;/** * */class LotteryAdapter extends AutoLottery implements ILottery&#123; public function __construct($hd_info) &#123; // 后台配置是否需要使用适配器 if($hd_info['use_adapter'] === true) &#123; $adapter_name = $hd_info['adapter_name']; // $adapter_name = 'adapter_name'; test $this-&gt;$adapter_name(); &#125; &#125; /** * adapter_name 该活动对应的适配器 */ private function adapter_name() &#123; // 假设不符合自动化的需求条件是必须进入游戏后5分才可抽奖，增加适配器的该内容即可，从而不用重写整个抽奖活动 $game_info = App::$app-&gt;model()-&gt;checkEnterGameInfo(); if(strtotime($info['TIME']) - time() &lt; 300) &#123; $this-&gt;adapter_status = false; $this-&gt;adapter_code = -51; &#125; &#125;&#125;namespace controller;use \\bbts\\App as BaseApp;/** * 自动化抽奖接口的基类 */class AutoLottery &#123; // 单独开发条件的状态 public $adapter_status = true; public $adapter_code = 0; public function _getLotteryResult()&#123; // 最后判断适配器的状态 if(!$this-&gt;adapter_status) &#123; App::jetJsonpOutput($this-&gt;adapter_return_code); &#125; // 业务逻辑判断 // 通过则将数据入库 $rs_status = App::$app-&gt;model()-&gt;insert($rs); // 返回结果 return $rs; &#125;&#125;?&gt;","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"状态设计模式","date":"2016-04-12T14:59:32.000Z","path":"2016/04/12/状态设计模式/","text":"什么时候适用状态设计模式 有大量的判断状态的条件 状态模式的作用就是允许对象在状态改变时改变其行为，所以根据业务需求进行分析。 最基本的场景例子(比起全部判断语句的做法，这不是更好么) 开灯关灯 扩展 开灯-&gt;加亮-&gt;再加亮-&gt;关灯 九宫格的数字移动游戏 优点 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来: 代码清晰可见，扩展性好 缺点 状态模式的使用必然会增加系统类和对象的个数。 只做开灯关灯例子说明 学习于php 设计模式（强烈推荐这本书）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;?php/** * content.class.php */class content &#123; private $onState; private $offState; private $currentState; public function __construct() &#123; $this-&gt;onState = new OnState($this); $this-&gt;offState = new offState($this); $this-&gt;currentState = $this-&gt;offState; &#125; /** * [trueOnLight 开灯] * @return [type] [description] */ public function trueOnLight() &#123; return $this-&gt;currentState-&gt;onLight(); &#125; /** * [trueOffLight 关灯] */ public function trueOffLight() &#123; return $this-&gt;currentState-&gt;offLight(); &#125; /** * [getState 取得关灯的实例] */ public function getOffState() &#123; return $this-&gt;offState; &#125; /** * [getOnState 取得开灯实例] * @return [type] [description] */ public function getOnState() &#123; return $this-&gt;onState; &#125; /** * [setState 设置当前的实例] * @param Istate $state [description] */ public function setState(Istate $state) &#123; $this-&gt;currentState = $state; &#125;&#125;/** * 接口 IState.php */interface IState &#123; function onLight(); function offLight();&#125;/** * 开灯状态 OnState.class.php */class OnState implements IState &#123; private $content; public function __construct(Content $content) &#123; $this-&gt;content = $content; &#125; /** * [onLight 开灯行为方法] */ public function onLight() &#123; return '已经开灯了&lt;br /&gt;'; &#125; /** * [offLight 关灯行为方法] */ public function offLight() &#123; $this-&gt;content-&gt;setState($this-&gt;content-&gt;getOffState()); return '关灯了&lt;br /&gt;'; &#125;&#125;/** * 关灯状态 OffState.class.php */class OffState implements IState &#123; private $content; public function __construct(Content $content) &#123; $this-&gt;content = $content; &#125; /** * [onLight 开灯行为方法] */ public function onLight() &#123; $this-&gt;content-&gt;setState($this-&gt;content-&gt;getOnState()); return '开灯了&lt;br /&gt;'; &#125; /** * [offLight 关灯行为方法] */ public function offLight() &#123; return '已经关灯了&lt;br /&gt;'; &#125;&#125;/** * 用户调用用例 */class client &#123; private $content; public function __construct() &#123; $this-&gt;content = new content(); echo $this-&gt;content-&gt;trueOnLight(); echo $this-&gt;content-&gt;trueOnLight(); echo $this-&gt;content-&gt;trueOffLight(); echo $this-&gt;content-&gt;trueOffLight();exit; &#125;&#125;$client = new client();?&gt;/** * 实例化一个Context 实例之后，初始请求是打开灯，因为灯默认是关的 ，请求显示的结果如下 * 开灯了 * 已经开灯了 * 关灯了 * 已经关灯了 */ 每一个行动中，我们必须把目光放到我们的过去、现在和将来的行动之外，还要超越这些行为影响到的其他人，而看到所有这一切之间的关系，这样一来，我们就会非常的谨慎","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"单例模式","date":"2016-04-11T12:04:54.000Z","path":"2016/04/11/单例模式/","text":"单例模式的特点 只能有一个实例 必须自行创建这个实例 必须给其他对象提供这一实例 单例类 构造函数需要标记为private（访问控制：防止外部代码使用new操作符创建对象），单例类不能在其他类中实例化，只能被其自身实例化； 拥有一个保存类的实例的静态成员变量(非成静态员：所有没有加Static的成员都是非静态成员,当类被实例化之后,可以通过实例化的类名进行访问..非静态成员的生存期决定于该类的生存期..而静态成员则不存在生存期的概念,因为静态成员始终驻留在内容中..) 拥有一个访问这个实例的公共的静态方法（常用getInstance()方法进行实例化单例类，通过instanceof操作符可以检测到类是否已经被实例化） 为什么要使用PHP单例模式？ 虽然PHP每次执行完页面都是会从内存中清理掉所有的资源. 因而PHP中的单例实际每次运行都是需要重新实例化的，但PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 优点： 改进系统的设计 是对全局变量的一种改进 缺点： 难于调试 隐藏的依赖关系 无法用错误类型的数据覆写一个单例","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"秒杀活动的架构设计","date":"2016-03-09T09:04:18.000Z","path":"2016/03/09/秒杀活动的架构设计/","text":"业务的基本说明 运营评估最高的并发会达到 10W（根据推广的力度，以及以往的经验） 业务现有的服务器架构 反向代理 4台，前端机 8台， db 2台（主从），redis 2台（主从）以下是服务器架构图 动静分离html 等静态文件上CDN ，这方面压力不大后台程序动态接口，必须支持高并发，用户体验必须做好后端程序优化点（欢迎大家补充） 程序尽可能的减少加载的文件 程序减少不必要的网络请求 redis 队列来作 异步方式实现 123// 后台进程消费队列 个人使用brpoplpush方法 取出数据并用存入另外队列作数据备份$block_expire_time = 0; # 设置阻塞等待时间为永久$redis-&gt;brpoplpush($key, $backup_key, $block_expire_time); redis 缓存 前端点击按钮请求后变灰，防止用户重复点击 静态文件上CDN nginx的最大连接数设置为550，防止连接数过大时全部到php，导致php服务挂了 针对每个用户加并发锁（redis），防止高并发情况判断条件被绕过,程序执行完后解锁。 1$lock_status = $redis-&gt;set($lock_key, 1, array(\"NX\", \"EX\"=&gt;$expire_time)); 高并发下奖品超发问题个人设计的方案：提前把每个奖品放入 redis队列，每个key一个奖品，队列的长度是奖品的数量，可以保证奖品不会超发放另外，假设使用悲观锁，在更新数据的时候加锁，其它的都为等待状态，不合适秒杀场景乐观锁 基本是采用带版本号更新，版本号匹配才能更新，其它的回滚，虽然保证的数据的安全不超发放，但是在高并发场景下，DB只有两台的时候，超过mysql 进程堆积肯定会的， 超过最大连接数是怎么办，一系列的问题需要解决，所以该方案不合适 程序压测结果分析服务器能抗的并发在平均响应时间300ms内，单台qps 750 左右（保持300ms是公司压测试的规范指标）10台机器（后面新增2台到 8+2）一秒钟能处理： 10 * 750/0.3 = 25000但是系统在高并发的状态下，响应时间有可能从300ms 变成500ms，所以在做评估，需要预留一定的空间那么问题来了，保守的并发只有1.5W,与10w 差距大，需要在执行方案上解决，公司不可无限的申请web机器。解决10W并发问题(资源有限的情况)方案在代理层做处理，根据权重挡掉90%的量，返回800（自定义），前端判断是否为800，是则提示火爆用户重试（对应的方案设置友好一些） 活动的序列图及说明 接口程序不连接查询mysql数据库 奖品的数据存放redis队列，每个奖品一个key，队列长度是奖品的数量 用户成功领取红包（或抢购）时的代码流程（不包括业务限制与防刷），从队列获取奖品成功，再入队列（此队列后台消费入库），返回给用户领取成功。在用户体验上有所提升，但如果后台队列堆积太多，未能消费完成，用户查看的红包时是没有对应记录的，所以针对自己的需求作对应的优化。 活动流程图（开爷画的）","tags":[{"name":"架构设计","slug":"架构设计","permalink":"http://yoursite.com/tags/架构设计/"}]},{"title":"用脚步丈量家乡 - 汕尾","date":"2016-02-22T10:00:11.000Z","path":"2016/02/22/用脚步丈量家乡-汕尾/","text":"汕尾或许汕尾这个城市鲜为人知，一般情况下说汕尾，对方都会复读一次是“汕头”来确认，但汕尾确实是以后可以养老的好地方，空气质量好，生活节奏慢. 不过大家都为了理想而各奔东西，每年回家乡的次数也有限，借着春节的假期，各种聚会的疯狂过后，去认真的体会一下家乡的自然与空气，这种熟悉且又有了陌生的感觉，让人心平气静。 沿着汕尾海边街，一路顶着海风飞（man）奔（pao）起来，想知道在海边跑步是什么感受的话，我来告诉你，就一个字，爽。 下面贴个跑步的小地图 海边街相比广州珠江边，这里更具有清新的气息，看着这条路上运动的人越来越多，个人感觉是汕尾人民对自我生活的一种提升吧。 跑步有一片蓝天，像玩家有着好的游戏体验一样，跑步真是一项最简单的运动","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"Mysql 查询今天、昨天、最近7天、最近30天的优化","date":"2016-01-10T15:48:47.000Z","path":"2016/01/10/Mysql 查询今天、昨天、最近7天、最近30天的优化/","text":"表结构1234567CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `createtime` int(11) NOT NULL DEFAULT '0', `price` varchar(32) NOT NULL, PRIMARY KEY (`id`), KEY `createtime` (`createtime`) USING BTREE) ENGINE=InnoDB CHARSET=utf8; 查询分析 今天、昨天、最近7天、最近30天的收入总数1234567explain select sum(price) as number from table where to_days(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d'))=to_days(now()) UNION ALL SELECT sum(price) as number FROM table WHERE TO_DAYS( NOW( ) ) - TO_DAYS( date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d')) &lt;= 1 &amp;&amp; to_days(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d'))!=to_days(now()) UNION ALL SELECT sum(price) as number FROM table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d')) UNION ALL SELECT sum(price) as number FROM table where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d')) 加了索引的情况下用不到索引 这里是图片 使用php程序时使用12345678910111213141516explain select sum(price) as number from student where to_days(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d'))=to_days(now()) UNION ALL SELECT sum(price) as number FROM student WHERE TO_DAYS( NOW( ) ) - TO_DAYS( date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d')) &lt;= 1 &amp;&amp; to_days(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d'))!=to_days(now()) UNION ALL SELECT sum(price) as number FROM student where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d')) UNION ALL SELECT sum(price) as number FROM student where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(date_format(FROM_UNIXTIME(`createtime`),'%Y-%m-%d'))explain select sum(price) as number from student where createtime&gt;='1489161600'UNION ALL SELECT sum(price) as number FROM student WHERE createtime&gt;='1489075200' &amp;&amp; createtime&lt;='1489161600'UNION ALL SELECT sum(price) as number FROM student where createtime&gt;='1488556800' &amp;&amp; createtime&lt;='1489247999'UNION ALL SELECT sum(price) as number FROM student where createtime&gt;='1486483200' &amp;&amp; createtime&lt;='1489247999' 优化方法后续补","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Mysql 字段类型","date":"2016-01-03T12:16:38.000Z","path":"2016/01/03/Mysql-字段类型/","text":"CHAR 类型是定长 删除末尾的空格，不会删除前面的空格 适合存储很短的字符串，或者所有值都接近同一个长度。例如: 适合存储MD5的密码串 定长的CHAR不容易产生碎片 对于非常短的列，CHAR比VARCHAR在存储更有效率。例如: CHAR(1) 来存储只有Y 和 N 的值，VARCHAR需要2个字节，CHAR只需要一个字节 VARCHAR 可变长的字符串 比定长类型CHAR更节省空间 需要使用额外的1 个或2个字符串来记录字符串的长度，小于255 只使用一个字节，大于使用2个 整数类型 TINYINT - 8 , SMALLINT - 16, MEDIUMINT - 24, INT - 32, BIGINT - 64 位的存储空间 -2的N-1次方到 2的N-1次方-12:可选 UNSIGNED属性 ，表示不允许负值 ，大致可以使正数上限提高一倍 实数类型 实数是带有小数部分的数字，也可以使用BECIMAL 格式 create table ta (a float,b decimal(6,5));6为小数点左边的位数，5为小数点右边的位数，当插入的小数点右边的位数大于5 后面的将被截掉，当插入小数点左边的位数大于6时，将取 999999 DECIMAL 是存储精确的小数，应该尽量只在小数进行精确计算时才使用，但数据量较大时，可以考虑使用BIGINT代替，要精确到万分之一的数据，可以把所有金额乘以一百万再存储进BIGINT里。 FLOAT 占用4个字节 DOUBLE占用8个字节 相比FLOAT有更高的精度与更大的范围 DATETIME 和 TIMESAMP 都可以存储相同的数据，时间和日期 TIMESAMP 只使用DATETIME一半的存储空间（4个字节与8个字节），并且根据时区变化，具有特殊的自动更新能力，但TIMESTAMP允许的时间范围小得多 DATETIME 范围 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 TIMESAMP 范围 1970-01-01 08:00:01到2038-01-19 11:14:07 TIMESTAMP类型在默认情况下，insert、update 数据时，TIMESTAMP列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新 使用INT存时间戳在业务上不方便处理的情况下，不建议使用 BLOB与TEXT 类型 BLOB 和TEXT类型都是为了存储很大的数据而设计的，分别采用二进制和字符方式存储 二进制类型有TINYBLOB,SMALLBLOB,BLOB,MEDIUMBLOB,LONGBLOB，字符类型是 TINYTEXT,SMALLTEXT,TEXT,MEDIUMTEXT,LONGTEXT，ENUM枚举与FIELD指定排序顺序 选择优化的数据类型 更小的数据类型通常更好,它们占用更小的磁盘，内存和CPU缓存，处理时需要的CPU周期更少 简单就好,整型比字符操作代价更低，因为字符集和校对规则使字符比较整型比较更复杂 尽量避免NULL 查询中包含可为NULL对MYSQL来说更难优化，因为可为NULL的列使得索引、索引统计和值 比较都较为复杂 可为NULL 的列使使用更多的存储空间，MYSQL里也需要特殊处理，当可为NULL被索引时,每个索引记录需要额外的字节 调优时，把可为NULL调为NOT NULL带来的性能提升比较小，除非确定此问题导致问题 使用VARCHAR(5) 与 VARCHAR(200)存储的区别 存储HELLO的空间开销是一样的，但是更长的列会消耗更多的内存，因为MYSQL通常会分配固定大小内存块来保存内部值 尤其是使用内存临时表时表进行排序或操作时会更糟糕","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"Mysql 覆盖索引","date":"2016-01-02T02:53:13.000Z","path":"2016/01/02/Mysql-覆盖索引/","text":"概述 覆盖索引能够极大地提高性能。 考虑一下如果查询只需要扫描索引而无须回表，会带来多少好处 索引的条目通常远小于数据行大小，所以如果只需要读取索引，那极大地减少数据访问量，所以更内容全部放在内存中 索引是按照列值顺序存储的（至少单个页内是这样的） 一些存储引擎如MyISAM 的内存只缓存索引。 由于innodb 的聚簇索引，覆盖索引 对Innodb表特别有用。 Innodb的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询 mysql 只能用b-tree索引来做覆盖索引 当发起一个被索引覆盖的查询时，在 EXPLAIN 的extra列可以看到 “Using index”的信息 例子 explain select * from prodcuts where actor = &quot;yeyute&quot; and title like &apos; %aplollo%&apos;; 没有任务索引能够覆盖这个查询，因为查询从表中选择了所有的列， 不过 where 条件中的表是有索引可以覆盖的 mysql 不能在索引中执行like 操作 。 mysql5.5以为更早版本，只允许在索引中做简单操作（&gt; 和 &gt;= 和 != ）,这种情况，mysql 只能提取数据行的值而不是索引值来做比较 使用索引扫描来做排序 explain type列的值为“index” 如果索引不能覆盖查询所需的全部列，就得扫描查询所需的全部列 mysql 可以使用同一个索引既满足排序，又用于查找行 关联多表时，只有当order by 子句引用的字段全部为第一个表时，才能使用索引做排序 建立（sex,country），查询时不限制性别，可以在查询条件新增 sex in(‘m’,’f’) and country=’’ 来使用索引","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"Mysql 聚簇索引(Clustered Index)","date":"2016-01-01T06:18:32.000Z","path":"2016/01/01/Mysql-聚簇索引/","text":"概述 每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放，但是，一个表可以有不止一个非聚簇索引。例:你翻到新华字典的汉字“爬”那一页就是P开头的部分，这就是物理存储顺序（聚簇索引）；而不用你到目录，找到汉字“爬”所在的页码，然后根据页码找到这个字（非聚簇索引） 如果需要该索引,只要将索引指定为主键(primary key)就可以，根据主键创建聚簇索引 如果正在使用Innodb 表并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT 自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。 顺序的主键会造成什么坏的结果？ 在高并发插入可能导致间隙锁竞争，可以考虑重新设计表，或者更改innodb_autoinc_lock_mode参数（innodb在语句1的实际插入操作执行前就预分配给该语句三个自增值，当有一个新的insert语句2要执行时，读取的AUTO_INCREMENT=4，这样虽然语句1可能还没有执行完，语句2就可直接执行无需等待语句2。） 什么时候用到聚簇索引以下将id设置为主键时，mysql 会根据主键创建聚簇索引,例：如果没设置主键，自增，where id=’1000’，是扫描全表123456CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` VARCHAR(32) NOT NULL DEFAULT '', `password` CHAR(32) NOT NULL DEFAULT '', PRIMARY KEY (`id`)) ENGINE=InnoDB CHARSET=utf8; 设置id为主键，自增，以下是对应的分析数据 1EXPLAIN select * from test_user where id='16000000' ; 字段 值 说明 select_type simple 简单的 select 查询,不使用 union 及子查询 table test_user 表名 partitions null 列代表给定表所使用的分区 type const 是说明只有一条匹配值， possible_keys PRIMARY 指出 MySQL 能在该表中使用哪些索引有助于 查询。如果为空,说明没有可用的索引 key PRIMARY MySQL 实际从 possible_key 选择使用的索引 key_len 4 使用的索引的长度。在不损失精确性的情况 下,长度越短越好 ref const where 条件筛选后表上至多有一条元组匹配时 rows 1 MYSQL 认为必须检查的用来返回请求数据的行数 filtered 100 列给出了一个百分比的值，这个百分比值和rows列的值一起使用，可以估计出那些将要和QEP中的前一个表进行连接的行的数目。前一个表就是指id列的值比当前表的id小的表 主键设置为那个字段合适情况分析 选择聚簇索引应基于where子句和连接操作的类型。 在聚簇索引中不要包含经常修改的列，因为值修改后，数据行必须移动到新的位置。 大多数表都应该有聚簇索引或使用分区来降低对表尾页的竞争，在一个高事务的环境中，对最后一页的封锁严重影响系统的吞吐量 在聚簇索引下，数据在物理上按顺序排在数据页上，重复值也排在一起，因而在那些包含范围检查(between、&lt;、&lt;=、&amp; gt;、&gt;=)或使用group by或order by的查询时，一旦找到具有范围中第一个键值的行，具有后续索引值的行保证物理上毗连在一起而不必进一步搜索，避免了大范围扫描，可以大大提高查询速度。 在一个频繁发生插入操作的表上建立聚簇索引时，不要建在具有单调上升值的列(如IDENTITY)上，否则会经常引起封锁冲突。 用户名字段，可以设置为主键，但是不推荐1.用户名是比较规则字母数字序列，这可能导致性能上有所差别2.假如以用户名作为主键并与其他表关联，当删除用户时，再创建一个同名的用户，可能导致这些关联紊乱。而绝对唯一的ID则不会。3.有的系统可能会允许修改用户名，如果以用户名为主键，将带来很多麻烦。而如果以ID为主键进行关联，则没有此问题。 聚簇索引中的记录是如何存放 节点页只包含了索引列，叶子页包含了行的全部数据，就是既存储索引值,又在叶子中存储行的数据 Innodb是通过主键聚集数据，如果没有主键，Innodb会选择一个唯一的非空索引代替。如果没有这样的索引，会隐式定义一个主键来作为聚簇索引。 聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列 优点 可以把相关的数据保存在一起。 例如电子邮件，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘的I/O. 数据访问更快。将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引查找更快 使用覆盖索引扫描的查询可以直接使用页节点中的主键值 缺点 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚会簇索引也就没什么优势 更新索引列代价很大，因为innodb 强制将每个被更新的行移动到新的位置 插入的速度严重依赖于插入顺充，按照主键的顺序插入是加载数据到INNODB表中速度最快的方式，如果不是，那么加载完成后最好 使用optimize table命令重新排序 对于插入新行，或主键更新，导致需要移动行的时候，可能面临“页分裂”问题。 当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，会导致表占用更大的磁盘空间 可能会导致全表扫描变慢，尤其是行比较稀疏 或者 页分裂 存储不连续的时候","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"http 请求报文详解","date":"2015-09-02T16:51:24.000Z","path":"2015/09/03/http-请求信息详解/","text":"两类报文 请求报文 响应报文 报文分三部分对报文进行描述的起始行（start line）请求报文 GET /php.info HTTP/1.1 报文内容 说明 GET 请求的方法 /php.info 请求的地址 HTTP/1.1 请求版本 响应报文 HTTP/1.1 200 OK 报文内容 说明 HTTP/1.1 响应版本 200 OK 响应的状态码 内容 包含属性的首部（header）块请求报文 报文内容 说明 accept(接收) 指定客户端能够接收的内容类型 text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8 Accept-Encoding gzip(数据格式 ), deflate(默认且目前仅使用deflate算法压缩data部分，此法用于压缩传输), sdch(即通过字典压缩算法对各个页面中相同的内容进行压缩，减少相同的内容的传输。如：一个网站中一般都是共同的头部和尾部，甚至一些侧边栏也是共同的。之前的方式每个页面打开的时候这些共同的信息都要重新加载，但使用SDCH压缩方式的话，那些共同的内容只用传输一次就可以了) Accept-Language zh-cn ,zh; q=0.8 接收语言Cache-Control: Cache-Control 值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。 而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如： Cache-control: max-age=5(表示当访问此网页后的5秒 内再次访问不会去服务器) connection keep-alive 默认是长连接 其优点是、在资源包含多个元素是(比如web页面中的图片)将减少下载时间，当Connection为Keep-Alive时、表示在Keep-Alive时间内不会断开连接。而非KeepAlive模式时、请求之后都将会断开 host 域名或ip If-Modified-Since 使用If-Modified-Since标签，把上次服务器告诉它的文件最后修改时间返回到服务器端了，文件没有改动过，所以服务器返回的HTTP状态码是304，没有发送页面的内容 Upgrade-Insecure-Requests 值为1 则是告诉服务器，自己支持这种操作，也就是我能读懂你服务器发过来的上面这条信息，并且在以后发请求的时候不用http而用https User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 表示请求的客户端浏览器详细信息 响应报文 报文内容 说明 Connection keep-alive* 默认是长连接 其优点是、在资源包含多个元素是(比如web页面中的图片)将减少下载时间，当Connection为Keep-Alive时、表示在Keep-Alive时间内不会断开连接。而非KeepAlive模式时、请求之后都将会断开 Content-Encoding 响应正文使用的数据压缩格式 Content-language 响应正文使用的语言 Content-Type 响应正文的类型（是图片还是二进制字符串） Date 服务器响应的时间 Last-Modified Sun, 26 Jun 2016 04:14:32 GMT* 最后修改的时间 Server nginx/1.6.2* http服务器的类型/版本 这个有时会造成有人专门利用特定版本网页服务器漏洞进行攻击，nginx可以在配置文件中增加或修改server_tokens off 来去除版本号 Link Accept-Encoding 响应头，明确告知缓存服务器按照 Accept-Encoding 字段的内容，分别缓存不同的版本 Set-Cookie AST_LANG=zh; expires=Mon, 26-Jun-2015 14:37:17 GMT; Max-Age=31536000; path=/; domain=.php.net* Transfer-Encoding chunked 分块编码 表示输出的内容长度不能确定，报文中的实体需要改为用一系列分块来传输，每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF(\\r\\n)，也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束 Vary 参考此文章 https://imququ.com/post/vary-header-in-http.html X-Frame-Options DENY：浏览器拒绝当前页面加载任何Frame页面，SAMEORIGIN：frame页面的地址只能为同源域名下的页面，ALLOW-FROM：origin为允许frame加载的页面地址 X-Powered-By PHP/5.2.1，可在php.ini中增加或修改 expose_php = Off关闭,使用了ThinkPHP会输出 ThinkPHP 2.0，可修改相关类文件关闭 Cache-Control max-age=600 表示当访问此网页后的600秒内 告诉浏览器再次访问不去访问服务器 Expires HTTP控制缓存的基本手段，这个属性告诉缓存器：相关副本在多长时间内是新鲜的。过了这个时间，缓存器就会向源服务器发送请求，检查文档是否被修 改。几乎所有的缓存服务器 Content-Length 实体长度 通常如果 Content-Length 比实际长度短，会造成内容被截断;如果比实体内容长，会造成 pending 可选的、包含数据的主体（body）就是http 要传输的内容","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"http 代理","date":"2015-07-02T17:16:49.000Z","path":"2015/07/03/http-代理详解/","text":"web 代理(proxy)代理位于客户端和服务器之间，扮演“中间人”的角色，对web客户端来说是扮演服务器的角色，对服务器来说是扮演客户端的角色 代理与网关的对比代理连接的是两个或多个使用相同协议的应用程序网关扮演的是“协议转换器”的角色，即使客户端和服务器使用的是不同的协议，客户端也可以通过网关完成与服务器之间的事务处理，例：浏览器&lt;-&gt;web/e-mail 网关(pop) &lt;-&gt; e-mail服务器 ，网关将不同的协议连接起来 为什么使用代理，运用的场景 代理服务器可以看到并接触到所有流过的http流量，所以代理可以监视流量并对其进行修改应用的场景 集中式访问控制代理(对禁止的站点强行禁止访问) 集中式文档访问控制代理 安全防火墙(提高安全性，以便对流量进行详细的检查) web 缓存 反向代理，以制作于分布式网络 内容路由器（根据网络流量状态以及内容类型将请求导向特定的服务器） 转码器 例：可以在传输gif图片时，将其转换成jpeg图片，减少尺寸，也可以对图片进行压缩，同样可以对文本压缩 匿名者（主动从http报文中删除身份特性，例ip，from头部，referer(请求报头，告知服务器用户的来源页面)首部，cookie,uri的会话id） 反向代理与正向代理反射代理 - 保护和隐藏原始资源服务器 情景- 用户 c -&gt;代理 a -&gt;机器 b 正向代理 - 主体是 c，a是c的代理 反向代理 - 主体是 c，a是b的代理 代理服务器的部署的几种方式 出口代理 控制本地网络与大型因特网之间的流量，公司部分网站控制访问等 访问（入口）代理 用于处理客户的聚合请求，。ISP使用缓存代理来存储常用文档的副本来提高用户的下载速度 反向代理 网络交换代理 将具有足够能力的代理放在网络之间的因特网对等交换点上，通过缓存来减轻因特网节点的拥塞，并对流量进行监视 代理如何获取流量的 修改客户端 - 手动或自动修改浏览器代理配置，客户端的http请求直接发给代理 修改网络 - 在客户端不知道的情况下，拦截网络流量并将其导入代理，这种拦截称为拦截代理。例：连接使用公共wifi时，会有将所有的站点修改到本地的hosts,获取拦截的流量信息后再请求问点返回。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"CGI、FastCGI、PHP-CGI、PHP-FPM 关系简单分析","date":"2015-05-11T02:12:52.000Z","path":"2015/05/11/CGI、FastCGI、PHP-CGI、PHP-FPM-关系简单分析/","text":"CGI、FastCGI、PHP-CGI、PHP-FPM 关系简单总结 value Description CGI 抽象来说是通用的服务网关， 标准的CGI对每个请求都会解析php.ini文件，初始化执行环境 PHP-CGI php-cgi只是解释PHP脚本的程序而已 FastCGI 一种管理php-cgi的协议(抽象)，一套由操作系统管理的php-cgi管理程序(具体) ，是用来提高CGI程序性能的 PHP-FPM 实现fast-cgi协议的具体程序 例：mvc与tp框架的关系， mvc是一种设计模式，tp框架是实现mvc模式的具体程序。","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"深入理解 Memcached","date":"2015-03-11T06:41:37.000Z","path":"2015/03/11/深入理解-Memcached/","text":"特性 单个item 最大的数据 1M 单进程最大的使用内存 2G ，需要更多内存时可开多个端口 memcached 是多线程，非阻塞io复用的网络模型，redis 是单线程 键长最大250字节 MEMCACHE_COMPRESSED为压缩选项，缩后数据一般为原数据大小的30%左右，节省了70%的传输性能消耗所得会大于文件压缩带来的性能损耗；存的数据的确有大于几百字节的，如果都是小于100字节的键值对，压缩可能反而带来膨胀， 常见的运用场景 memcached来保持session，实现session共享（session跨服务器的一种解决方案） 解释压缩 注：php 官网的memcache 扩展的最新几个版本，当value好像是大于20k时（具体数值待验证），会自动压缩，尝试过压缩后有乱码情况,尝试使用1。1版本的不会自动压缩的情况 1set($this-&gt;_key($key), $value, MEMCACHE_COMPRESSED, $ttl); MEMCACHE_COMPRESSED为压缩选项缩后数据一般为原数据大小的30%左右，节省了70%的传输性能消耗所得会大于文件压缩带来的性能损耗；存的数据的确有大于几百字节的，如果都是小于100字节的键值对，压缩可能反而带来膨胀，Memcached中都是按照固定大小分块存储的，最小也要88 B。所以对于过小数据带来的压缩膨胀并不是太大的问题； 内存管理机制（默认是使用Slab Allocatoion机制分配、管理内存） 将内存分割成各种尺寸的块(chunk),并把尺寸相同的块分成组(chunk的集合) page 是分配Slab的内存空间 默认是1M 根据Slab大小切分成chunk chunk:用户缓存记录的内存空间 Slab class：特定chunk的组 如何组织数据的呢？内存分配流程 内存单位 说明 slab 数据大小相似的为一类, 放在同一个slab中.(按照chunk分类) page 每个page分配1M大小, 该类slab下的chunk用完, 重新申请一个page; 分配一次的大小. 如果没有page, 每次分配初始化一个chunk太浪费资源. chunk 数据存放最小也是最大的单位, 一个key对应的数据不能跨chunk(默认最大为1M) 内存分配参数 说明 used_chunks 已分配给item的chunk数量, 只分配, 不一定使用（初始化） free_chunks 尚未分配的chunk数量, 由delete释放的chunk(get不到时也会释放) free_chunks_end 分配后还没有被使用过的chunk","tags":[{"name":"nosql","slug":"nosql","permalink":"http://yoursite.com/tags/nosql/"}]},{"title":"hexo 命令","date":"2015-03-10T02:06:47.000Z","path":"2015/03/10/hexo-命令/","text":"安装123456# 全局安装安装npm install hexo -g# 升级 npm update hexo -g # 初始化 hexo init 简写123456# 本地启动服务hexo s == hexo server # 生成静态文件hexo g = hexo generate # 部署,将代码上传到配置的服务器hexo d == hexo deploy 新建1234# 新建文章hexo new \"postName\"# 新建页面 hexo new page \"pageName\" 删除删除 ./source/_posts/里对应的md文件. ps:不能全部删除，会报错。然后对应执行 123hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 hexo clean,直接把public下的所有文章和分类目录都删除了,tags,archices,categories也会重新布局,请小心操作 服务器123456789101112131415# Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server # 静态模式hexo server -s # 更改端口hexo server -p 5000 # 自定义 IPhexo server -i 192.168.1.1# 清除缓存 网页正常情况下可以忽略此条命令,public 文件夹内容将全部删除hexo clean # 生成静态网页hexo g # 开始部署hexo d 监视文件变动1234# 使用 Hexo 生成静态文件快速而且简单hexo generate# 监视文件变动hexo generate --watch","tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]}]