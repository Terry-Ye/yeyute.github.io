[{"title":"【学习笔记】hexo 命令","date":"2017-03-03T02:06:47.000Z","path":"2017/03/03/【学习笔记】hexo-命令/","text":"安装123456# 全局安装安装npm install hexo -g# 升级 npm update hexo -g # 初始化 hexo init 简写123456# 本地启动服务hexo s == hexo server # 生成静态文件hexo g = hexo generate # 部署,将代码上传到配置的服务器hexo d == hexo deploy 新建1234# 新建文章hexo new \"postName\"# 新建页面 hexo new page \"pageName\" 删除删除 ./source/_posts/里对应的md文件. ps:不能全部删除，会报错。然后对应执行 123hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 hexo clean,直接把public下的所有文章和分类目录都删除了,tags,archices,categories也会重新布局,请小心操作 服务器123456789101112131415# Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server # 静态模式hexo server -s # 更改端口hexo server -p 5000 # 自定义 IPhexo server -i 192.168.1.1# 清除缓存 网页正常情况下可以忽略此条命令,public 文件夹内容将全部删除hexo clean # 生成静态网页hexo g # 开始部署hexo d 监视文件变动1234# 使用 Hexo 生成静态文件快速而且简单hexo generate# 监视文件变动hexo generate --watch","tags":[]},{"title":"秒杀活动的架构设计","date":"2016-03-09T09:04:18.000Z","path":"2016/03/09/秒杀活动的架构设计/","text":"业务的基本说明 运营评估最高的并发会达到 10W（根据推广的力度，以及以往的经验） 业务现有的服务器架构 反向代理 4台，前端机 8台， db 2台（主从），redis 2台（主从）以下是服务器架构图 动静分离html 等静态文件上CDN ，这方面压力不大后台程序动态接口，必须支持高并发，用户体验必须做好后端程序优化点（欢迎大家补充） 程序尽可能的减少加载的文件 程序减少不必要的网络请求 redis 队列来作 异步方式实现 123// 后台进程消费队列 个人使用brpoplpush方法 取出数据并用存入另外队列作数据备份$block_expire_time = 0; # 设置阻塞等待时间为永久$redis-&gt;brpoplpush($key, $backup_key, $block_expire_time); redis 缓存 前端点击按钮请求后变灰，防止用户重复点击 静态文件上CDN nginx的最大连接数设置为550，防止连接数过大时全部到php，导致php服务挂了 针对每个用户加并发锁（redis），防止高并发情况判断条件被绕过,程序执行完后解锁。 1$lock_status = $redis-&gt;set($lock_key, 1, array(\"NX\", \"EX\"=&gt;$expire_time)); 高并发下奖品超发问题个人设计的方案：提前把每个奖品放入 redis队列，每个key一个奖品，队列的长度是奖品的数量，可以保证奖品不会超发放另外，假设使用悲观锁，在更新数据的时候加锁，其它的都为等待状态，不合适秒杀场景乐观锁 基本是采用带版本号更新，版本号匹配才能更新，其它的回滚，虽然保证的数据的安全不超发放，但是在高并发场景下，DB只有两台的时候，超过mysql 进程堆积肯定会的， 超过最大连接数是怎么办，一系列的问题需要解决，所以该方案不合适 程序压测结果分析服务器能抗的并发在平均响应时间300ms内，单台qps 750 左右（保持300ms是公司压测试的规范指标）10台机器（后面新增2台到 8+2）一秒钟能处理： 10 * 750/0.3 = 25000但是系统在高并发的状态下，响应时间有可能从300ms 变成500ms，所以在做评估，需要预留一定的空间那么问题来了，保守的并发只有1.5W,与10w 差距大，需要在执行方案上解决，公司不可无限的申请web机器。解决10W并发问题(资源有限的情况)方案在代理层做处理，根据权重挡掉90%的量，返回800（自定义），前端判断是否为800，是则提示火爆用户重试（对应的方案设置友好一些） 活动的序列图及说明 接口程序不连接查询mysql数据库 奖品的数据存放redis队列，每个奖品一个key，队列长度是奖品的数量 用户成功领取红包（或抢购）时的代码流程（不包括业务限制与防刷），从队列获取奖品成功，再入队列（此队列后台消费入库），返回给用户领取成功。在用户体验上有所提升，但如果后台队列堆积太多，未能消费完成，用户查看的红包时是没有对应记录的，所以针对自己的需求作对应的优化。 活动流程图（开爷画的）","tags":[{"name":"架构设计","slug":"架构设计","permalink":"http://yoursite.com/tags/架构设计/"}]},{"title":"CGI、FastCGI、PHP-CGI、PHP-FPM 关系简单分析","date":"2015-05-11T02:12:52.000Z","path":"2015/05/11/CGI、FastCGI、PHP-CGI、PHP-FPM-关系简单分析/","text":"CGI、FastCGI、PHP-CGI、PHP-FPM 关系简单总结 value Description CGI 抽象来说是通用的服务网关， 标准的CGI对每个请求都会解析php.ini文件，初始化执行环境 PHP-CGI php-cgi只是解释PHP脚本的程序而已 FastCGI 一种管理php-cgi的协议(抽象)，一套由操作系统管理的php-cgi管理程序(具体) ，是用来提高CGI程序性能的 PHP-FPM 实现fast-cgi协议的具体程序 例：mvc与tp框架的关系， mvc是一种设计模式，tp框架是实现mvc模式的具体程序。","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"深入理解 Memcached","date":"2015-03-11T06:41:37.000Z","path":"2015/03/11/深入理解-Memcached/","text":"特性 单个item 最大的数据 1M 单进程最大的使用内存 2G ，需要更多内存时可开多个端口 memcached 是多线程，非阻塞io复用的网络模型，redis 是单线程 键长最大250字节 MEMCACHE_COMPRESSED为压缩选项，缩后数据一般为原数据大小的30%左右，节省了70%的传输性能消耗所得会大于文件压缩带来的性能损耗；存的数据的确有大于几百字节的，如果都是小于100字节的键值对，压缩可能反而带来膨胀， 常见的运用场景 memcached来保持session，实现session共享（session跨服务器的一种解决方案） 解释压缩 注：php 官网的memcache 扩展的最新几个版本，当value好像是大于20k时（具体数值待验证），会自动压缩，尝试过压缩后有乱码情况,尝试使用1。1版本的不会自动压缩的情况 1set($this-&gt;_key($key), $value, MEMCACHE_COMPRESSED, $ttl); MEMCACHE_COMPRESSED为压缩选项缩后数据一般为原数据大小的30%左右，节省了70%的传输性能消耗所得会大于文件压缩带来的性能损耗；存的数据的确有大于几百字节的，如果都是小于100字节的键值对，压缩可能反而带来膨胀，Memcached中都是按照固定大小分块存储的，最小也要88 B。所以对于过小数据带来的压缩膨胀并不是太大的问题； 内存管理机制（默认是使用Slab Allocatoion机制分配、管理内存） 将内存分割成各种尺寸的块(chunk),并把尺寸相同的块分成组(chunk的集合) page 是分配Slab的内存空间 默认是1M 根据Slab大小切分成chunk chunk:用户缓存记录的内存空间 Slab class：特定chunk的组 如何组织数据的呢？内存分配流程 内存单位 说明 slab 数据大小相似的为一类, 放在同一个slab中.(按照chunk分类) page 每个page分配1M大小, 该类slab下的chunk用完, 重新申请一个page; 分配一次的大小. 如果没有page, 每次分配初始化一个chunk太浪费资源. chunk 数据存放最小也是最大的单位, 一个key对应的数据不能跨chunk(默认最大为1M) 内存分配参数 说明 used_chunks 已分配给item的chunk数量, 只分配, 不一定使用（初始化） free_chunks 尚未分配的chunk数量, 由delete释放的chunk(get不到时也会释放) free_chunks_end 分配后还没有被使用过的chunk","tags":[{"name":"nosql","slug":"nosql","permalink":"http://yoursite.com/tags/nosql/"}]}]